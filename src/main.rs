extern crate chrono;
extern crate docopt;
extern crate hyper;
extern crate regex;
extern crate rustc_serialize;

use docopt::Docopt;
use regex::Regex;
use std::collections::HashMap;

mod api2;
mod bzapi;

#[cfg_attr(rustfmt, rustfmt_skip)]
const USAGE: &'static str = "
Standups Weekly Report.

Usage:
  standups_weekly [-w] [-d <date>]
  standups_weekly -h

Options:
  -h --help                  Show this screen.
  -d <date>, --date <date>   The date in yyyy-mm-dd format.
  -w --wiki                  Output report in mediawiki format.
";

fn titlecase(input: &str) -> String {
    input.chars()
        .enumerate()
        .map(|(i, c)| {
            if i == 0 {
                c.to_uppercase().next().unwrap()
            } else {
                c
            }
        })
        .collect()
}

fn textify(maybe_html: &str) -> String {
    let bug_re = Regex::new("<a href=\"http://bugzilla[^\"]+\">[Bb]ug\\s+(?P<number>\\d+)</a>")
        .unwrap();
    let text = bug_re.replace_all(maybe_html, "$number");

    let bug_re = Regex::new("(?P<number>\\d{5,})").unwrap();
    bug_re.replace_all(&text, "bug $number")
}

fn extract_bug_numbers(input: &str) -> Vec<u32> {
    let bug_re = Regex::new("[Bb]ug\\s+(?P<number>\\d+)").unwrap();
    bug_re.captures_iter(input)
        .map(|caps| caps.name("number").unwrap().parse().unwrap())
        .collect()
}

fn print_section(section: &str, wiki: bool) {
    if wiki {
        println!("\n== {} ==", section);
    } else {
        println!("\n## {} ##", section);
    }
}

fn main() {
    let args = Docopt::new(USAGE)
        .and_then(|dopt| dopt.parse())
        .unwrap_or_else(|e| e.exit());

    let date = args.get_str("--date");
    let wiki = args.get_bool("--wiki");
    let decoded = api2::get_project_timeline("perf-tw", date);

    let mut reports = HashMap::new();
    let mut bug_numbers = Vec::new();

    for status in &decoded {
        let vec = reports.entry(&status.user.username).or_insert_with(Vec::new);
        vec.push(titlecase(&textify(&status.content)));
        bug_numbers.extend(extract_bug_numbers(&status.content));
    }
    let bug_details = bzapi::get_bugs(&bug_numbers);

    for (username, status) in &mut reports {
        status.sort();
        status.dedup();

        print_section(username, wiki);
        if wiki {
            let mut bugs_map = HashMap::new();
            let mut no_bugs_reports = Vec::new();
            for content in status {
                let bugs = extract_bug_numbers(content);
                if bugs.is_empty() {
                    no_bugs_reports.push(content.clone());
                } else {
                    for bug in bugs {
                        let vec = bugs_map.entry(bug).or_insert_with(Vec::new);
                        vec.push(content.clone());
                    }
                }
            }
            for report in no_bugs_reports {
                println!("* {}", report);
            }
            for (bug, vec) in &bugs_map {
                match bug_details.get(bug) {
                    Some(bug_data) =>
                        println!("* {{{{bug|{}}}}} {}", bug, bug_data),
                    None =>
                        println!("* {{{{bug|{}}}}} {}", bug, "Invalid bug or security bug"),
                };
                for content in vec {
                    println!("** {}", content);
                }
            }
        } else {
            let mut bugs = Vec::new();
            for content in status {
                println!("  * {}", content);
                bugs.extend(extract_bug_numbers(content));
            }
            if !bugs.is_empty() {
                println!("");
                bugs.sort();
                bugs.dedup();
                for bug in &bugs {
                    let data = bug_details.get(bug).unwrap();
                    println!("  * https://bugzil.la/{} {}", data.id, data);
                }
            }
        }
    }

    if wiki {
        println!("\n\n<small>");
    } else {
        println!("\n\n");
    }
    println!("This report is automatically generated by \
              https://github.com/kanru/standups_weekly");
    if wiki {
        println!("</small>");
    }
}
